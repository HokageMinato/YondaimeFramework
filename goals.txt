
Improvements:
 > [DONE] Rename SystemLibrary to SceneLibrary. 

 > [DONE]RootLibrary resides in DontDestoryOnLoad and is updated sceneLibrary upon
	loading and unloading of scene.
	
 > [DONE] Add FindBehaviour-s<T>() to CustomBehaviour which scans from RootLibrary and finds 
	everthing related from its system libraries.
	
 > [DONE]GetComponentByID in sceneLibrary and a dictionary which maintains stuff mapped to ID
 
 > [DONE] Ids from several instances of containers combined, showing all of them together in drawer.
   
 > [DONE] None option for ID 
 
 > [DONE] Horizontal layout display for editor buttons 
 
 > [DONE] Optimized GetComponentFromGameObject by assigning indexes to objects. 
 
 > [DONE] GetComponentByID, 

 > [DONE] ComponentId Seperate comparision and display value
 
 > An override of BehaviourLibrary where active and inactive objects are seperated acc to position, left from midde inactive right from middle active
   or different lookups for active inactive and return combined incase of all queried;
   Extra methods in CustomBehaviour with inactiveObjects support. 
 
 > Add an exception for "No Parsed Id in current scriptable, Please click assign from container from container SO"
 
 > Decorator based Init with order for maintaining initializations; [Init,Order='']
 
 > Check if _lookUp.Clear is really required in library intializations
 
 > Performance Optimization, preallocate List count during generation in GetComponent(s) methods in SceneLibrary to Preallocate list during method call
 
 > Add proper Exceptions for [Library not assigned] [Library not initialized] [Nulls Present in Library, require refresh]

 > [NR][For Now]locking of resource when queried during hierarchy change, or hierarchy change during query.
 
 > See if Serialized class instances can anyhow be added to this, just for fun
 
 > ================ {FEATURE NOTE } ===================
   => Interface:
		-> A ComponentLibrary interface

   => Working:
		-> All methods will work as they are supposed to be.
		-> Every GComponent method variant will have a boolean for including pooled object list.
		-> GetComponent variants will return every instance,(including pooled) when queried
		-> In library, two HPerformanceList will be present, One to hold pooled, one to hold inUse components.
		-> We will not depend on gameobjects' activeStatus state, but on last method called i.e. Pooled or depooled.
		-> 'Including pooled' ticked on will just pull everything from both list while decluding pool will only pool from active list.

   => Primary architecture:	
		-> Keep scenelibrary inheriting behaviourLibrary, but make behaviourLibrary implement ComponentLibrary
		-> Similarly make PooledLibrary implement ComponentLibrary
		-> GetComponent alternatives should have an WithActive counterparts, which scans both lists and returns them

   => Create a CustomPooledBehaviour extending CustomBehaviour
		-> Add two methods GetPooled<T>() and PoolSelf();
		-> those two will call PooledLibrary's GetPooled<T>() and Pool(T behv)
		-> Add a virtual cleanup() method in CustomPooledBehaviour to perform custom cleanup (if any required)
   ====================={ END }========================